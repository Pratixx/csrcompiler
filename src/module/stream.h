#pragma once

// [ DEFINING ] //

typedef enum {
	
	// General tokens
	TOKEN_TYPE_UNDEFINED,
	TOKEN_TYPE_INVALID,
	TOKEN_TYPE_EOF,
	
	TOKEN_TYPE_LITERAL,
	TOKEN_TYPE_TYPE,
	TOKEN_TYPE_IDENTIFIER,
	
	// Punctuator tokens
	TOKEN_TYPE_PT_SEMICOLON,
	TOKEN_TYPE_PT_COMMA,
	TOKEN_TYPE_PT_PERIOD,
	TOKEN_TYPE_PT_COLON,
	TOKEN_TYPE_PT_ARROW,
	
	TOKEN_TYPE_PT_OPEN_PAREN,
	TOKEN_TYPE_PT_CLOSE_PAREN,
	
	TOKEN_TYPE_PT_OPEN_BRACE,
	TOKEN_TYPE_PT_CLOSE_BRACE,
	
	TOKEN_TYPE_PT_OPEN_BRACKET,
	TOKEN_TYPE_PT_CLOSE_BRACKET,
	
	// Type tokens
	TOKEN_TYPE_TYPE_PTR,
	TOKEN_TYPE_TYPE_REF, // Might not use this
	
	// Operator tokens
	TOKEN_TYPE_OP_ADD,
	TOKEN_TYPE_OP_SUB,
	TOKEN_TYPE_OP_MUL,
	TOKEN_TYPE_OP_DIV,
	
	TOKEN_TYPE_OP_MOD,
	
	TOKEN_TYPE_OP_INC,
	TOKEN_TYPE_OP_DEC,
	
	TOKEN_TYPE_OP_TERNARY_IF,
	TOKEN_TYPE_OP_TERNARY_ELSE,
	
	TOKEN_TYPE_OP_DEREF,
	TOKEN_TYPE_OP_REF,
	
	// Comparison operator tokens
	TOKEN_TYPE_OP_CMP_EQUAL,
	TOKEN_TYPE_OP_CMP_LESS_EQUAL,
	TOKEN_TYPE_OP_CMP_GREATER_EQUAL,
	TOKEN_TYPE_OP_CMP_LESS,
	TOKEN_TYPE_OP_CMP_GREATER,
	TOKEN_TYPE_OP_CMP_AND,
	TOKEN_TYPE_OP_CMP_OR,
	TOKEN_TYPE_OP_CMP_NOT,
	
	// Assignment operator tokens
	TOKEN_TYPE_OP_ASSIGN,
	
	TOKEN_TYPE_OP_ASSIGN_ADD,
	TOKEN_TYPE_OP_ASSIGN_SUB,
	TOKEN_TYPE_OP_ASSIGN_MUL,
	TOKEN_TYPE_OP_ASSIGN_DIV,
	TOKEN_TYPE_OP_ASSIGN_MOD,
	
	// Bitwise operator tokens
	TOKEN_TYPE_OP_BIT_AND,
	TOKEN_TYPE_OP_BIT_OR,
	TOKEN_TYPE_OP_BIT_NOT,
	TOKEN_TYPE_OP_BIT_XOR,
	TOKEN_TYPE_OP_BIT_SHIFT_LEFT,
	TOKEN_TYPE_OP_BIT_SHIFT_RIGHT,
	
	// Bitwise assignment operator tokens
	TOKEN_TYPE_OP_ASSIGN_BIT_AND,
	TOKEN_TYPE_OP_ASSIGN_BIT_OR,
	TOKEN_TYPE_OP_ASSIGN_BIT_NOT,
	TOKEN_TYPE_OP_ASSIGN_BIT_XOR,
	TOKEN_TYPE_OP_ASSIGN_BIT_SHIFT_LEFT,
	TOKEN_TYPE_OP_ASSIGN_BIT_SHIFT_RIGHT,
	
	// Keyword tokens
	TOKEN_TYPE_KW_RETURN,
	
	TOKEN_TYPE_KW_STRUCT,
	TOKEN_TYPE_KW_ENUM,
	TOKEN_TYPE_KW_UNION,
	
	TOKEN_TYPE_KW_NAMESPACE,
	
	TOKEN_TYPE_KW_AUTO,
	
	TOKEN_TYPE_KW_STATIC,
	
	TOKEN_TYPE_KW_INLINE,
	
	TOKEN_TYPE_KW_USING,
	
	TOKEN_TYPE_KW_IF,
	TOKEN_TYPE_KW_ELSE,
	
	TOKEN_TYPE_KW_WHILE,
	TOKEN_TYPE_KW_FOR,
	TOKEN_TYPE_KW_CONTINUE,
	
	TOKEN_TYPE_KW_SWITCH,
	TOKEN_TYPE_KW_CASE,
	TOKEN_TYPE_KW_DEFAULT,
	
	TOKEN_TYPE_KW_BREAK,
	TOKEN_TYPE_KW_JUMP,
	
	TOKEN_TYPE_KW_IMPORT,
	TOKEN_TYPE_KW_EXPORT,
	TOKEN_TYPE_KW_MODULE,
	TOKEN_TYPE_KW_HEADER,
	
} token_type;

typedef struct token {
	token_type type;
	char value[MAX_VALUE_LEN];
} token;

/*////////*/

typedef enum {
	STREAM_SUCCESS,
	STREAM_ERROR_MEM_ALLOC,
} stream_error;

typedef struct {
	code* pCode;
} stream_info;

typedef struct {
	size_t memSize;
	size_t size;
	size_t index;
	token* buffer;
} stream;

// [ FUNCTIONS ] //

void stream_print(stream* pStream);

stream_error stream_create(stream* pStream, stream_info* pInfo);
void stream_destroy(stream* pStream);