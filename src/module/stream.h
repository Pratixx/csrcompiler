#pragma once

// [ DEFINING ] //

typedef enum {
	
	// General tokens
	TOKEN_TYPE_UNDEFINED,
	TOKEN_TYPE_INVALID,
	TOKEN_TYPE_EOF,
	
	TOKEN_TYPE_IDENTIFIER,
	
	// Literal tokens
	TOKEN_TYPE_LITERAL_CHAR,
	TOKEN_TYPE_LITERAL_STR,
	TOKEN_TYPE_LITERAL_INT,
	TOKEN_TYPE_LITERAL_INT_HEX,
	TOKEN_TYPE_LITERAL_FLOAT,
	
	// Punctuator tokens
	TOKEN_TYPE_PT_AMPERSAND,
	TOKEN_TYPE_PT_SEMICOLON,
	TOKEN_TYPE_PT_COMMA,
	TOKEN_TYPE_PT_PERIOD,
	TOKEN_TYPE_PT_COLON,
	TOKEN_TYPE_PT_ARROW,
	TOKEN_TYPE_PT_QUESTION,
	
	TOKEN_TYPE_PT_OPEN_PAREN,
	TOKEN_TYPE_PT_CLOSE_PAREN,
	
	TOKEN_TYPE_PT_OPEN_BRACE,
	TOKEN_TYPE_PT_CLOSE_BRACE,
	
	TOKEN_TYPE_PT_OPEN_BRACKET,
	TOKEN_TYPE_PT_CLOSE_BRACKET,
	
	// Operator tokens
	TOKEN_TYPE_OP_ADD,
	TOKEN_TYPE_OP_SUB,
	TOKEN_TYPE_OP_MUL,
	TOKEN_TYPE_OP_DIV,
	
	TOKEN_TYPE_OP_MOD,
	
	TOKEN_TYPE_OP_INC,
	TOKEN_TYPE_OP_DEC,
	
	TOKEN_TYPE_OP_TERNARY_IF,
	TOKEN_TYPE_OP_TERNARY_ELSE,
	
	TOKEN_TYPE_OP_DEREF,
	TOKEN_TYPE_OP_REF,
	
	// Comparison operator tokens
	TOKEN_TYPE_OP_CMP_EQUAL,
	TOKEN_TYPE_OP_CMP_LESS_EQUAL,
	TOKEN_TYPE_OP_CMP_GREATER_EQUAL,
	TOKEN_TYPE_OP_CMP_LESS,
	TOKEN_TYPE_OP_CMP_GREATER,
	TOKEN_TYPE_OP_CMP_AND,
	TOKEN_TYPE_OP_CMP_OR,
	TOKEN_TYPE_OP_CMP_NOT,
	
	// Assignment operator tokens
	TOKEN_TYPE_OP_ASSIGN,
	
	TOKEN_TYPE_OP_ASSIGN_ADD,
	TOKEN_TYPE_OP_ASSIGN_SUB,
	TOKEN_TYPE_OP_ASSIGN_MUL,
	TOKEN_TYPE_OP_ASSIGN_DIV,
	TOKEN_TYPE_OP_ASSIGN_MOD,
	
	// Bitwise operator tokens
	TOKEN_TYPE_OP_BIT_AND,
	TOKEN_TYPE_OP_BIT_OR,
	TOKEN_TYPE_OP_BIT_NOT,
	TOKEN_TYPE_OP_BIT_XOR,
	TOKEN_TYPE_OP_BIT_SHIFT_LEFT,
	TOKEN_TYPE_OP_BIT_SHIFT_RIGHT,
	
	// Bitwise assignment operator tokens
	TOKEN_TYPE_OP_ASSIGN_BIT_AND,
	TOKEN_TYPE_OP_ASSIGN_BIT_OR,
	TOKEN_TYPE_OP_ASSIGN_BIT_NOT,
	TOKEN_TYPE_OP_ASSIGN_BIT_XOR,
	TOKEN_TYPE_OP_ASSIGN_BIT_SHIFT_LEFT,
	TOKEN_TYPE_OP_ASSIGN_BIT_SHIFT_RIGHT,
	
	// Type specifier tokens
	TOKEN_TYPE_SP_PTR,
	
	TOKEN_TYPE_SP_VOID,
	
	TOKEN_TYPE_SP_LONG,
	TOKEN_TYPE_SP_SHORT,
	
	TOKEN_TYPE_SP_SIGNED,
	
	// Type qualifier tokens
	TOKEN_TYPE_QU_CONST,
	TOKEN_TYPE_QU_RESTRICT,
	TOKEN_TYPE_QU_VOLATILE,
	TOKEN_TYPE_QU_ATOMIC,
	TOKEN_TYPE_QU_THREAD_LOCAL,
	TOKEN_TYPE_QU_AUTO,
	TOKEN_TYPE_QU_STATIC,
	
	// Keyword tokens
	TOKEN_TYPE_KW_RETURN,
	
	TOKEN_TYPE_KW_STRUCT,
	TOKEN_TYPE_KW_ENUM,
	TOKEN_TYPE_KW_UNION,
	
	TOKEN_TYPE_KW_NAMESPACE,
	
	TOKEN_TYPE_KW_USING,
	
	TOKEN_TYPE_KW_IF,
	TOKEN_TYPE_KW_ELSE,
	TOKEN_TYPE_KW_SWITCH,
	TOKEN_TYPE_KW_CASE,
	
	TOKEN_TYPE_KW_WHILE,
	TOKEN_TYPE_KW_FOR,
	TOKEN_TYPE_KW_CONTINUE,
	
	TOKEN_TYPE_KW_BREAK,
	TOKEN_TYPE_KW_JUMP,
	
	TOKEN_TYPE_KW_IMPORT,
	TOKEN_TYPE_KW_EXPORT,
	TOKEN_TYPE_KW_MODULE,
	TOKEN_TYPE_KW_HEADER,
	
} token_type;

typedef struct token {
	token_type type;
	char value[MAX_VALUE_LEN];
} token;

/*////////*/

typedef struct {
	code* pCode;
	symbol_table* pSymbolTable;
} stream_info;

typedef struct {
	size_t memSize;
	size_t size;
	size_t index;
	token* buffer;
} stream;

// [ FUNCTIONS ] //

void stream_print(stream* pStream);

bool stream_create(stream* pStream, stream_info* pInfo);
void stream_destroy(stream* pStream);